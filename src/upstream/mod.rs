// SPDX-License-Identifier: Apache-2.0

#![allow(unused)]

use crate::lang::LanguageConfig;
use crate::lang::java::Java;
use crate::upstream::matched::UpstreamMatch;
use anyhow::{Context, bail};
use gix::bstr::ByteSlice;
use gix::traverse::tree::Recorder;
use gix::traverse::tree::recorder::Entry;
use sha2::Digest;
use std::path::PathBuf;
use streaming_iterator::StreamingIterator;
use tokio::fs;
use tracing::{debug, trace};
use tree_sitter::{Parser, QueryCursor};
use url::Url;
use walkdir::{DirEntry, WalkDir};
use wax::{BuildError, Glob, Pattern};

pub mod matched;
pub mod matcher;

pub type UpstreamId = String;

pub struct Upstream<'t> {
    /// Unique ID for upstream
    pub id: UpstreamId,

    /// Human-friendly name of upstream
    pub name: String,

    /// Path to upstream git repository.
    ///
    /// This can be relative or absolute to suit your environment.
    pub path: PathBuf,

    /// Link to the repository for display purposes
    pub repo: Option<Url>,

    /// List of source directories within this upstream
    pub roots: Vec<SourceRoot<'t>>,

    /// Optional human-friendly notes for this upstream
    pub notes: Option<String>,
}

impl<'t> Upstream<'t> {
    /// Collect all matched items for the given upstream configuration
    pub async fn scan(&self, revision: &str) -> anyhow::Result<Vec<UpstreamMatch>> {
        if !self.path.exists() {
            bail!("Could not find repository root at {}", self.path.display());
        }

        let mut matched_items = Vec::new();
        for root in &self.roots {
            let mut matches = root.scan(self, revision).await?;
            matched_items.append(&mut matches);
        }
        Ok(matched_items)
    }
}

/// Describes a source tree within an upstream repository.
pub struct SourceRoot<'t> {
    /// ID for source root, unique within the upstream.
    pub id: String,

    /// Human-friendly name for source root
    pub name: String,

    /// Language used within this source root
    pub lang: Box<dyn LanguageConfig>,

    /// Optional human-friendly notes for this language
    pub notes: Option<String>,

    /// List of globs matching files that are eligible for processing with the
    /// language's matchers. This list is pruned by the excludes list.
    pub includes: Vec<Glob<'t>>,

    /// List of globs that prune file list generated by the includes.
    pub excludes: Vec<Glob<'t>>,
}

impl<'t> SourceRoot<'t> {
    pub async fn scan(
        &self,
        upstream: &Upstream<'t>,
        revision: &str,
    ) -> anyhow::Result<Vec<UpstreamMatch>> {
        let mut matched_items = Vec::new();

        // Build glob filters
        let includes = wax::any(self.includes.clone())
            .with_context(|| format!("Compile includes for Source Root {}", &self.id))?;
        let excludes = wax::any(self.excludes.clone())
            .with_context(|| format!("Compile excludes for Source Root {}", &self.id))?;

        let repo_path = upstream.path.clone();
        let repo = gix::discover(&repo_path)
            .with_context(|| format!("Open git repo at {}", &repo_path.display()))?;

        let rev = repo
            .rev_parse_single(revision)
            .with_context(|| format!("Get revision for {revision}"))?;
        let tree = rev
            .object()
            .context("Object must exist for known-good revision")?
            .peel_to_tree()
            .context("Get tree for revision object")?;

        // Process file tree
        let mut recorder = Recorder::default();
        tree.traverse()
            .breadthfirst(&mut recorder)
            .with_context(|| format!("Enumerate all items in tree at revision {revision})"))?;

        let entries: Vec<Entry> = recorder
            .records
            .into_iter()
            // TODO symlink handling with .is_blob_or_symlink()
            .filter(|entry| entry.mode.is_blob())
            .collect();

        println!(
            "Filtering {} entries in repo at revision {} ({})",
            entries.len(),
            revision,
            rev.to_hex()
        );
        for entry in entries {
            let path = entry.filepath.to_path().context("Convert path to String")?;

            // Upstream include/exclude filters
            if !includes.is_match(path) {
                continue;
            };
            if excludes.is_match(path) {
                continue;
            }

            // Language-level path filter has a final veto
            if !self.lang.should_parse(path) {
                continue;
            };

            // Set up parser
            let mut parser = Parser::new();
            parser.set_language(&self.lang.language())?;

            // Get data from repo blob
            let file_blob = repo
                .find_blob(entry.oid)
                .context("Get blob for file data")?;
            let data = &file_blob.data;

            // Parse tree and extract matches
            let tree = parser.parse(data, None).context("Parse source file")?;
            for matcher in self.lang.matchers()? {
                let mut cursor = QueryCursor::new();
                let query = matcher.query;

                let mut matches = cursor.matches(&query, tree.root_node(), data.as_slice());

                println!("{} - {}", path.display(), matcher.kind);
                while let Some(matched) = matches.next() {
                    if matched.captures.is_empty() {
                        continue;
                    }

                    // Find outer range of captures, which might be out of order
                    let start_byte = matched.captures.iter().fold(usize::MAX, |acc, cap| {
                        usize::min(acc, cap.node.start_byte())
                    });
                    let end_byte = matched
                        .captures
                        .iter()
                        .fold(usize::MIN, |acc, cap| usize::max(acc, cap.node.end_byte()));

                    // TODO Range check
                    let bytes = &data[start_byte..end_byte];
                    let checksum = sha2::Sha256::digest(&bytes);
                    println!("  {checksum:02x}")
                    // TODO Extract ident and build Matched
                }
            }
        }

        Ok(matched_items)
    }
}

/// Perform a scan with a hard-coded upstream
#[tokio::test]
async fn test_scan() -> anyhow::Result<()> {
    let cwd = std::env::current_dir()?;
    println!("{:?}", cwd);

    let upstream = Upstream {
        id: "self-test".to_string(),
        name: "Internal Tests".to_string(),
        path: PathBuf::from("./"),
        repo: None,
        roots: vec![SourceRoot {
            id: "java".into(),
            name: "Java".into(),
            lang: Box::new(Java {}),
            notes: None,
            includes: vec![Glob::new("tests/**/*.java")?],
            excludes: vec![],
        }],
        notes: None,
    };

    let results = upstream.scan("main").await?;
    println!("Found {} results", results.len());
    dbg!(&results);

    Ok(())
}

#[tokio::test]
async fn test_scan_sdfs() -> anyhow::Result<()> {
    let cwd = std::env::current_dir()?;
    println!("{:?}", cwd);

    let upstream = Upstream {
        id: "self-test".to_string(),
        name: "Internal Tests".to_string(),
        path: PathBuf::from("../../OSS/sdfs"),
        repo: None,
        roots: vec![SourceRoot {
            id: "java".into(),
            name: "Java".into(),
            lang: Box::new(Java {}),
            notes: None,
            includes: vec![Glob::new("src/**/*.java")?],
            excludes: vec![],
        }],
        notes: None,
    };

    let results = upstream.scan("master").await?;
    println!("Found {} results", results.len());
    dbg!(&results);

    Ok(())
}

#[tokio::test]
async fn test_scan_cassandra() -> anyhow::Result<()> {
    let cwd = std::env::current_dir()?;
    println!("{:?}", cwd);

    let upstream = Upstream {
        id: "self-test".to_string(),
        name: "Internal Tests".to_string(),
        path: PathBuf::from("../../OSS/cassandra"),
        repo: None,
        roots: vec![SourceRoot {
            id: "java".into(),
            name: "Java".into(),
            lang: Box::new(Java {}),
            notes: None,
            includes: vec![Glob::new("src/**/*.java")?],
            excludes: vec![],
        }],
        notes: None,
    };

    let results = upstream.scan("trunk").await?;
    println!("Found {} results", results.len());
    dbg!(&results);

    Ok(())
}
