// SPDX-License-Identifier: Apache-2.0

#![allow(unused)]

use crate::DatabaseArgs;
use crate::lang::java::Java;
use crate::lang::{Dialect, LanguageDefinition};
use crate::upstream::matched::UpstreamMatch;
use anyhow::{Context, Error, bail};
use clap::Args;
use gix::bstr::ByteSlice;
use gix::traverse::tree::Recorder;
use gix::traverse::tree::recorder::Entry;
use gix::{Repository, ThreadSafeRepository};
use gix_glob::Pattern;
use gix_glob::wildmatch::Mode;
use sha2::Digest;
use std::path::{Path, PathBuf};
use streaming_iterator::StreamingIterator;
use tokio::fs;
use tokio::task::JoinSet;
use tracing::{debug, trace};
use tree_sitter::{Parser, QueryCursor};
use url::Url;
use walkdir::{DirEntry, WalkDir};

pub mod matched;
pub mod matcher;

pub type UpstreamId = String;

#[derive(Args, Clone, Debug)]
pub struct UpstreamScanArgs {
    #[command(flatten)]
    pub database: DatabaseArgs,

    /// Path to upstream Git Repository
    pub repo_path: PathBuf,

    /// Git branch or hash to scan
    pub revision: String,
}

pub struct Upstream {
    /// Unique ID for upstream
    pub id: UpstreamId,

    /// Human-friendly name of upstream
    pub name: String,

    /// Path to upstream git repository.
    ///
    /// This can be relative or absolute to suit your environment.
    pub path: PathBuf,

    /// Link to the repository for display purposes
    pub repo: Option<Url>,

    /// List of source directories within this upstream
    pub roots: Vec<SourceRoot>,

    /// Optional human-friendly notes for this upstream
    pub notes: Option<String>,
}

impl Upstream {
    /// Collect all matched items for the given upstream configuration
    pub async fn scan(&self, revision: &str) -> anyhow::Result<Vec<UpstreamMatch>> {
        if !self.path.exists() {
            bail!("Could not find repository root at {}", self.path.display());
        }

        let mut matched_items = Vec::new();
        for root in &self.roots {
            let mut matches = root.scan(self, revision).await?;
            matched_items.append(&mut matches);
        }
        Ok(matched_items)
    }
}

/// Describes a source tree within an upstream repository.
pub struct SourceRoot {
    /// ID for source root, unique within the upstream.
    pub id: String,

    /// Human-friendly name for source root
    pub name: String,

    /// Language and matchers used within this source root
    pub lang: Dialect,

    /// Optional human-friendly notes for this language
    pub notes: Option<String>,

    /// List of globs matching files that are eligible for processing with the
    /// language's matchers. This list is pruned by the excludes list.
    pub includes: Vec<(Pattern, Mode)>,

    /// List of globs that prune file list generated by the includes.
    pub excludes: Vec<(Pattern, Mode)>,
}

impl SourceRoot {
    pub async fn scan(
        &self,
        upstream: &Upstream,
        revision: &str,
    ) -> anyhow::Result<Vec<UpstreamMatch>> {
        let mut matched_items = Vec::new();

        let repo_path = upstream.path.clone();
        let repo_sync = gix::open(&repo_path)
            .with_context(|| format!("Open git repo at {}", &repo_path.display()))?
            .into_sync();

        let repo = repo_sync.clone().to_thread_local();
        let rev = repo
            .rev_parse_single(revision)
            .with_context(|| format!("Get revision for {revision}"))?;
        let tree = rev
            .object()
            .context("Object must exist for known-good revision")?
            .peel_to_tree()
            .context("Get tree for revision object")?;

        // Process file tree
        let mut recorder = Recorder::default();
        tree.traverse()
            .breadthfirst(&mut recorder)
            .with_context(|| format!("Enumerate all items in tree at revision {revision})"))?;

        let entries: Vec<Entry> = recorder
            .records
            .into_iter()
            // TODO symlink handling with .is_blob_or_symlink()
            .filter(|entry| entry.mode.is_blob())
            .collect();

        println!(
            "Filtering {} entries in repo at revision {} ({})",
            entries.len(),
            revision,
            rev.to_hex()
        );

        // Threading here. Use a JoinSet and join_all
        // Consider spawn_blocking as the entire block is synchronous, on top of the IO.
        // https://docs.rs/tokio/latest/tokio/task/struct.JoinSet.html#method.spawn_blocking
        //
        // 3700 files in 90 seconds (20 seconds with --release) is Considerably more than the
        // recommended 100Âµs between awaits. Blocking threads are preferred in this case.
        // Gix-Glob (--release) also finishes in 20 seconds.
        //
        // Rayon is likely the best option as matchers become more numerous and complex.
        // https://stackoverflow.com/a/74547875/140930
        //
        // Further discussion referenced by the above: https://ryhl.io/blog/async-what-is-blocking/
        // Use rayon and tokio::sync::oneshot to await the results.
        //
        // Use Gix Threadsafe Mode with repo.into_sync() and clone for each thread.
        // https://docs.rs/gix/latest/gix/#threadsafe-mode
        // https://docs.rs/gix/latest/gix/struct.ThreadSafeRepository.html

        // Process file entry.
        for entry in entries {
            // Upstream include/exclude filters
            if !self
                .includes
                .iter()
                .any(|(pat, mode)| pat.matches(entry.filepath.as_ref(), *mode))
            {
                continue;
            };
            if self
                .excludes
                .iter()
                .any(|(pat, mode)| pat.matches(entry.filepath.as_ref(), *mode))
            {
                continue;
            }

            // Language-level path filter has a final veto

            let repo = repo_sync.clone();
            let mut matches = self.process_entry(&repo, &entry)?;
            matched_items.append(&mut matches);
        }

        Ok(matched_items)
    }

    fn process_entry(
        &self,
        repo: &ThreadSafeRepository,
        entry: &Entry,
    ) -> anyhow::Result<Vec<UpstreamMatch>> {
        let repo = repo.to_thread_local();
        let mut matches = Vec::new();

        // Set up parser
        let mut parser = Parser::new();
        parser.set_language(&self.lang.language)?;

        // Get data from repo blob
        let file_blob = repo
            .find_blob(entry.oid)
            .context("Get blob for file data")?;
        let data = &file_blob.data;

        // Parse tree and extract matches
        let tree = parser.parse(data, None).context("Parse source file")?;
        for matcher in &self.lang.matchers {
            let mut cursor = QueryCursor::new();
            let query = &matcher.query;

            let mut matches = cursor.matches(&query, tree.root_node(), data.as_slice());

            while let Some(matched) = matches.next() {
                if matched.captures.is_empty() {
                    continue;
                }

                // Find outer range of captures, which might be out of order
                let start_byte = matched.captures.iter().fold(usize::MAX, |acc, cap| {
                    usize::min(acc, cap.node.start_byte())
                });
                let end_byte = matched
                    .captures
                    .iter()
                    .fold(usize::MIN, |acc, cap| usize::max(acc, cap.node.end_byte()));

                // TODO Range check
                let bytes = &data[start_byte..end_byte];
                let checksum = sha2::Sha256::digest(&bytes);
                trace!(
                    kind = matcher.kind,
                    checksum = format!("{:02x}", checksum),
                    file = entry.filepath.to_string(),
                    "Matched item"
                )
                // TODO Extract ident and build Matched
            }
        }
        Ok(matches)
    }
}

/// Perform a scan with a hard-coded upstream
#[tokio::test]
async fn test_scan() -> anyhow::Result<()> {
    let cwd = std::env::current_dir()?;
    println!("{:?}", cwd);

    let upstream = Upstream {
        id: "self-test".to_string(),
        name: "Internal Tests".to_string(),
        path: PathBuf::from("./"),
        repo: None,
        roots: vec![SourceRoot {
            id: "java".into(),
            name: "Java".into(),
            lang: Java {}.configuration()?,
            notes: None,
            includes: vec![(
                gix_glob::parse("tests/**/*.java").context("Glob should parse")?,
                Mode::NO_MATCH_SLASH_LITERAL,
            )],
            excludes: vec![],
        }],
        notes: None,
    };

    let results = upstream.scan("main").await?;
    println!("Found {} results", results.len());
    dbg!(&results);

    Ok(())
}

#[tokio::test]
async fn test_scan_sdfs() -> anyhow::Result<()> {
    let cwd = std::env::current_dir()?;
    println!("{:?}", cwd);

    let upstream = Upstream {
        id: "self-test".to_string(),
        name: "Internal Tests".to_string(),
        path: PathBuf::from("../../OSS/sdfs"),
        repo: None,
        roots: vec![SourceRoot {
            id: "java".into(),
            name: "Java".into(),
            lang: Java {}.configuration()?,
            notes: None,
            includes: vec![(
                gix_glob::parse("src/**/*.java").context("Glob should parse")?,
                Mode::NO_MATCH_SLASH_LITERAL,
            )],
            excludes: vec![],
        }],
        notes: None,
    };

    let results = upstream.scan("master").await?;
    println!("Found {} results", results.len());
    dbg!(&results);

    Ok(())
}

#[tokio::test]
async fn test_scan_cassandra() -> anyhow::Result<()> {
    let cwd = std::env::current_dir()?;
    println!("{:?}", cwd);

    let upstream = Upstream {
        id: "self-test".to_string(),
        name: "Internal Tests".to_string(),
        path: PathBuf::from("../../OSS/cassandra"),
        repo: None,
        roots: vec![SourceRoot {
            id: "java".into(),
            name: "Java".into(),
            lang: Java {}.configuration()?,
            notes: None,
            includes: vec![(
                gix_glob::parse("src/**/*.java").context("Glob should parse")?,
                Mode::NO_MATCH_SLASH_LITERAL,
            )],
            excludes: vec![],
        }],
        notes: None,
    };

    let results = upstream.scan("trunk").await?;
    println!("Found {} results", results.len());
    dbg!(&results);

    Ok(())
}
